class MinHeap:
    '''
    A simple fixed-sized minimun binary heap implemented on array
    '''
    def __init__(self, capacity: int, comp: func = None):
        self.arr = [None] * capacity
        self.comp = comp # comparison function, a "less than"
        self.count = 0

    def push(self, v):
        if self.count == len(self.arr):
            raise IndexError('')
 
        # Append to tail first
        self.arr[self.count] = v

        # Then lift up
        self.lift(self.count)

        self.count += 1

    def pop(self):
        if self.count < 1:
            raise IndexError('')

        self.count -= 1 
        ret = self.arr[0]
        
        # Move last element to top
        self.arr[0] = self.arr[self.count]
        self.arr[count] = None

        # Then sink it     
        self.sink(0)

        return ret

    def pushpop(self,v):
        if self.count < 1:
            return v
   
        top = self.arr[0]
        if self.comp(v, top):
            return v

        self.arr[0] = v
        self.sink(0)
        return top

    def top(self):
        if self.count < 1:
            raise IndexError('')
        
        return self.arr[0]
    
    def empty(self) -> bool:
        return self.count == 0
    
    def lift(self, i):
        '''
        Lift up value at i
        '''
        arr = self.arr
        
        while True:
            p = self.getParent(i)
            if p != i and self.lessThan(arr[i], arr[p]):
                arr[p],arr[i] = arr[i],arr[p]
                i = p
            else:
                break
                
    def sink(self, i):
        '''
        Push down value at i
        '''
        arr = self.arr
        count = self.count

        while True:
            '''
            Find if any children element is smaller than p
            '''
            smallest = i
            
            lt = self.getLeft(i)
            if lt < count and self.lessThan(arr[lt], arr[smallest]): 
                smallest = lt
                
            rt = self.getRight(i)
            if rt < count and self.lessThan(arr[rt], arr[smallest]):
                smallest = rt

            if smallest == i:
                break

            arr[i],arr[smallest] = arr[smallest],arr[i]
            i = smallest
           
    # Comparision helper
    def lessThan(self, a, b) -> bool:
        if self.comp:
            return self.comp(a, b)
        else:
            return a < b
    
    # Index helpers
    def getLeft(self, i):
        '''
        Get left child index of i
        '''
        return (i << 1) + 1

    def getRight(self, i):
        '''
        Get right child index of i
        '''
        return (i + 1) << 1

    def getParent(self, i):
        '''
        Get parent index of i
        If i is root or less then 0, return i
        '''
        return ((i - 1) >> 1) if i > 0 else i

# Not used
def heapify(arr) -> MinHeap:
    '''
    Transform list x into a heap, in-place, in linear time.
    '''
    n = len(arr)
    h = MinHeap(n)

    for i in range((n >> 1) - 1, -1, -1):
        sink(arr, i, n);

    h.arr = arr
    h.count = n

    return h
        
class BuildingWrapper:
    '''
    A wrapped-up class for heap usage
    '''
    def __init__(self, right, height):
        self.right = right
        self.height = height
    
    def __lt__(self, that) -> bool:
        # Revesed comparison, as Max Heap is needed
        return self.height > that.height

class Solution:
    def getSkyline(self, buildings: List[List[int]]) -> List[List[int]]:
        '''
        buidings: [[left, right, height]]
        '''
        size = len(buildings)      
        heap = MinHeap(size) # BuildingWrapper
        skyline = [] 
        
        i = 0      
        while i < size or len(heap) > 0:
            # if heap is empty or
            # next input's left bound is smaller or equal to top heap element right bound
            # do push
            # heap only contains buildings that are "overlapped" with highest one
            if heap.empty() or i < n and buildings[i][0] <= heap.top().right:
                nextBuildingLeft = buildings[i][0]
                
                # push all inputs with same left bound
                while i < n and buildings[i][0] == nextBuildingLeft:
                    heap.push(BuildingWrapper(buildings[i][1], buildings[i][2]))
                    i += 1
            else:
                topRight = heap.top().right # top element right bound
                # pop all elements with right bound smaller or equal to "right"
                # basically discard building whose right bound is covered by top element
                # to gurantee no duplicate bound
                while not heap.empty() and heap.top().right <= topRight:
                    heap.pop()

            # new height is from top element or 0
            height = 0 if heap.empty() else heap.top().height

            # do not add duplicate height
            # no duplicate bound will be add
            # "ind" is either from "if" or "else"
            if len(skyline) == 0 or height != skyline[-1][1]:
                skyline.append([ind, height])

        return skyline
